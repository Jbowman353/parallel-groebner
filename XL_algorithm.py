#!/usr/bin/env python
# coding: utf-8

import sympy as s
import numpy as np
from numba import cuda, jit, vectorize
import pycuda.autoinit
import pycuda.driver as drv
from pycuda.compiler import SourceModule


class XL:
    def __init__(self, F, D, ring, mode=None):
        """
        Inputs: 
        : F, a list of sympy.Poly() objects,
        : D, an integer for maximum degree
        : ring, a sympy ring() object with symbols, domain, order
        : mode, optional argument to change target

        Initialize function with list of sympy Poly objects,
        sympy ring with domain, all free symbols, and ordering,
        and user defined maximal degree.

        Mode will change the construction of coeff_matrix, and
        the function to which it is dispatched for reduction.

        Mode options include 'sympy', 'numpy', and 'cuda'.
        
        'sympy' will construct a Sympy Matrix object and
        run their built in rref() or echelon_form() function against it.
        Expected to be slower by comparison for large inputs.

        'numpy' will (should) construct an np.ndarray with the corresponding
        type for the ring.domain. QQ, RR will use np.float, and GF will use
        appropriate integer type. Currently targets numba's cpu jit

        'cuda' will construct either a numpy or a cupy matrix depending
        on availability, and execute a cuda kernel for gaussian elimination.
        May use cuda.jit, cuda.autojit, or an explicit pycuda kernel
        Still working on this part
        """
        self.F = F
        self.D = D
        self.ring = ring
        self.mode = mode
        self.G = set()
        self.sys_monoms = [list()] * D
    
    def __call__(self):
        """
        Simple implementation of XL algorithm initialized with Sympy
        objects to test CUDA performance on row reduction in GB calculation.
        Seems to perform reasonably well ona test GF2 field, and output is fairly
        stable, but it is noted by Faugere, Eder, et al that the behavior is 
        not as good as F4, and that the matrices generated by XL are enormous
        by comparison.

        Does not interreduce the basis, does not produce reduced or minimal GB,
        D-Grobner Basis only.
        """
        for d in range(1, self.D + 1):
            Fd = set()
            print("Starting iteration {}...".format(d))
            for f in self.F:
                if f.degree() == d:
                    Fd.add(f)
                elif f.degree() < d:
                    Md = set()
                    for i in range(len(f.monoms())):
                        if max(f.monoms()[i]) == (d - f.degree()):
                            if not max(f.monoms()) == 0:
                                m = s.poly(f.as_expr().as_ordered_terms()[i],
                                           domain=self.ring.domain)
                                Md.add(m) 
                    for m in Md:
                        Fd.add(m * f)
                        #print("{} added to Fd[{}]".format((m*f), d))
            self.update_monomials(Fd, d-1)
            self.G = self.reduction(self.coeff_matrix(self.G.union(Fd), d-1), d-1)
            print("Completed iteration {}".format(d))
        self.results()
        return self.G

    def coeff_matrix(self, G_Fd, cur_d):
        """
        Construct coefficient matrix from polynomials, cols corresponding
        to the monomials in sys_monoms ordered by ring.order, rows by decreasing
        maximal degree.

        Input: A set of polynomials from G.union(Fd[d])
        Output: A coefficient matrix in numpy ndarray or sympy matrix.
        """
        if self.mode not in ['sympy', 'numpy', 'cuda']:
            self.mode = 'sympy'

        cols = len(self.sys_monoms[cur_d])
        rows = len(G_Fd)
        
        if self.mode == 'sympy':
            coeff_matrix = s.zeros(rows, cols)
            for i, f in enumerate(G_Fd):
                for term in f.terms():
                    coeff_matrix[i, self.sys_monoms[cur_d].index(term[0])] = term[1]
            return coeff_matrix

        if self.mode == 'numpy':
            if self.ring.domain == s.GF(2):
                np_coeff_matrix = np.zeros((rows, cols), dtype=np.uint8)
            else:
                np_coeff_matrix = np.zeros((rows, cols), dtype=np.float)
            for i, f in enumerate(G_Fd):
                for term in f.terms():
                    np_coeff_matrix[i, self.sys_monoms[cur_d].index(term[0])] = term[1]
            return np_coeff_matrix

        if self.mode == 'cuda':
            """
            Not finished
            """ 
            if self.ring.domain == s.GF(2):
                cp_coeff_matrix = np.zeros((rows, cols), dtype=np.uint8)
                cp_ret_matrix = np.zeros((rows, cols), dtype=np.uint8)
            else:
                cp_coeff_matrix = np.zeros((rows, cols), dtype=np.float)
                cp_ret_matrix = np.zeros((rows, cols), dtype=np.float)

            for i, f in enumerate(G_Fd):
                for term in f.terms():
                    cp_coeff_matrix[i, self.sys_monoms[cur_d].index(term[0])] = term[1]
            return cp_coeff_matrix


    def reduction(self, coeff_mat, cur_d):
        """
        reduces coefficient matrix of (G U Fd) to echelon form using CUDA or CPU.
        """
        if self.mode == 'sympy':
            # RREF can only be used for QQ or float valued input.
            reduced_matrix = coeff_mat.echelon_form()
            red_mat_polys = []
            for m in range(reduced_matrix.rows):
                poly = []
                for n in range(reduced_matrix.cols):
                    if reduced_matrix[m, n] != 0:
                        poly.append((reduced_matrix[m, n],
                                     self.sys_monoms[cur_d][n]))
                red_mat_polys.append(poly)
            sympy_polys = self.conv_tup_to_expr(red_mat_polys)
            return set(sympy_polys)
        
        if self.mode == 'numpy':
            if self.ring.domain == s.GF(2):
                reduced_matrix = self.gauss_GF2(coeff_mat)
                print("Size: {}".format(reduced_matrix.shape))
            red_mat_polys = []
            rows, cols = reduced_matrix.shape
            for m in range(rows):
                poly = []
                for n in range(cols):
                    if reduced_matrix[m, n] != 0:
                        poly.append((reduced_matrix[m, n],
                                     self.sys_monoms[cur_d][n]))
                red_mat_polys.append(poly)
            sympy_polys = self.conv_tup_to_expr(red_mat_polys)
            return set(sympy_polys)

        if self.mode == 'cuda':
            if self.ring.domain == s.GF(2):
                #reduced_matrix = self.cuda_gauss_GF2(ret, coeff_mat)
                #print("Size: {}".format(reduced_matrix.shape))
            # Not done
            pass

    def update_monomials(self, Fd, cur_d):
        """
        Updates some stuff
        
        Input: A set of Polynomials Fd to be used to update sys_monoms.
        Output: VOID
        """        
        for f in Fd:
            for t in f.monoms():
                self.sys_monoms[cur_d].append(t)
        for g in self.G:
            for t in g.monoms():
                self.sys_monoms[cur_d].append(t)
        self.sys_monoms[cur_d] = sorted(list(set(self.sys_monoms[cur_d])),
                                        key=s.polys.orderings.monomial_key(
                                            order=self.ring.order), reverse=True)
        
    def results(self):
        """
        Returns the contents of F, G
        """
        print("Output from XL function")
        print("Input System")
        print("------------")
        for f in self.F:
            print(f)
        print("------------")
        print("Output D-Groebner Basis for degree {}".format(self.D))
        print("------------")
        print("Total: {}".format(len(self.G)))
        for i, g in enumerate(self.G):
            print("{}: {}".format(i, g.as_expr()))
        print("------------")
        print("System Monomials per each run d")
        print("------------")
        for d in range(1, self.D + 1):
            print('For degree {}...'.format(d))
            print("Total: {}".format(len(self.sys_monoms[d-1])))
            print("----------")

    def conv_tup_to_expr(self, poly_list):
        """
        Converts a list of tuples to a sympy expression.
        """
        expr_list = []
        for poly in poly_list:
            expr = []
            for term in poly:
                m_expr = ["+" + str(term[0])]
                for i, e in enumerate(term[1]):
                    m_expr.append("*" + str(self.ring.symbols[i]) + "**" + str(e))
                expr.append(''.join(m_expr))
            expr_list.append(s.poly_from_expr(''.join(expr),
                                              domain=self.ring.domain,
                                              order=self.ring.order)[0])
        return expr_list

    
    @staticmethod
    @jit(nopython=True, parallel=True, fastmath=True)
    def gauss_GF2(M):
        """
        Gaussian Elimination over GF(2). Input matrix should
        be of type np.uint8
        """
        m, n = M.shape

        i=0
        j=0

        while i < m and j < n:
            # find value and index of largest element in remainder of column j
            k = np.argmax(M[i:, j]) +i

            # swap rows
            #M[[k, i]] = M[[i, k]] this doesn't work with numba
            temp = np.copy(M[k])
            M[k] = M[i]
            M[i] = temp

            aijn = M[i, j:]
            col = np.copy(M[:, j]) #make a copy otherwise M will be directly affected
            col[i] = 0 #avoid xoring pivot row with itself
            flip = np.outer(col, aijn)
            M[:, j:] = M[:, j:] ^ flip

            i += 1
            j += 1

        return M


if __name__ == '__main__':
    """
    Initial example is Cyclic-4
    """
    Cyclic4_R, a, b, c, d = s.ring(symbols='a, b, c, d', domain='QQ', order='lex')
    f1 = s.poly_from_expr('a*b*c*d - 1', domain='QQ', order='lex')[0]
    f2 = s.poly_from_expr('a*b*c + a*b*d + a*c*d + b*c*d', domain='QQ', order='lex')[0]
    f3 = s.poly_from_expr('a*b + b*c + a*d + c*d', domain='QQ', order='lex')[0]
    f4 = s.poly_from_expr('a + b + c + d', domain='QQ', order='lex')[0]
    Cyclic4 = (f4, f3, f2, f1)
    
    # Here's a random system of 10 equations in 5 variables over GF(2)
    # Generated by M4GB's system generator script on their github.
    GF2_5_10_R, X0, X1, X2, X3, X4 = s.ring(symbols='X0,X1,X2,X3,X4', domain=s.GF(2), order='grevlex')
    f1 = s.poly_from_expr("X0**2+X0*X1+X1**2+X0*X2+X2**2+X0*X3+X1*X3+X2*X3+X3**2+X2+X4+1",
                          domain=s.GF(2))[0]
    f2 = s.poly_from_expr("X0**2 + X1**2 + X1*X2 + X2*X3 + X0*X4 + X4**2 + X0 + X4 + 1",
                          domain=s.GF(2))[0]
    f3 = s.poly_from_expr("X1**2 + X1*X3 + X2*X3 + X3**2 + X0*X4 + X2*X4 + X1 + X2 + X3",
                          domain=s.GF(2))[0]
    f4=s.poly_from_expr("X0**2+X0*X1+X0*X2+X1*X2+X2**2+X0*X3+X2*X3+X3**2+X0*X4+X2*X4+X4**2+X0+X1+X2",
                          domain=s.GF(2))[0]
    f5 = s.poly_from_expr("X0**2+X0*X1+X1**2+X0*X2+X1*X3+X3**2+X1*X4+X2*X4+X4**2+X0+X1+X2+X3+1",
                          domain=s.GF(2))[0]
    f6 = s.poly_from_expr("X1*X2+X1*X3+X2*X3+X0*X4+X1*X4+X2*X4+X3*X4+X0+X3",
                          domain=s.GF(2))[0]
    f7 = s.poly_from_expr("X0*X1+X1**2+X0*X2+X1*X2+X2**2+X2*X3+X2+X4+1",
                          domain=s.GF(2))[0]
    f8 = s.poly_from_expr("X0*X2+X1*X2+X0*X3+X3**2+X0*X4+X1*X4+X2*X4+X3*X4+X0+X2",
                          domain=s.GF(2))[0]
    f9 = s.poly_from_expr("X0*X1+X1**2+X1*X2+X2**2+X0*X3+X3**2+X1*X4+X2*X4+X4**2+X0+X4+1",
                          domain=s.GF(2))[0]
    f10 = s.poly_from_expr("X0*X1+X1**2+X0*X2+X1*X2+X2*X3+X3**2+X0*X4+X1*X4+X2*X4+X3+X4",
                           domain=s.GF(2))[0]
    GF2_5_10 = (f1, f2, f3, f4, f5, f6, f7, f8, f9, f10)

    D = int(input("Enter maximum degree: "))

    xl_gf2 = XL(GF2_5_10, D, GF2_5_10_R, mode='numpy')
    xl_cyclic4 = XL(Cyclic4, D, Cyclic4_R, mode='sympy')
